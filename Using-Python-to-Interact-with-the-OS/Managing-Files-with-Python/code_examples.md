Dumping code examples for each submodule here. This makes it easier for me to review quickly and hopefully keeps me awake. 

# Reading and Writing Files

## Reading Files

When we open a file the OS checks permissions to access the file and then gives our code a file descriptor. This is a token generated by the OS that allows programs to do more operations with the file. In Python, this file descriptor is stored as an attribute of the files object. The file object gives us a bunch of methods that we can use to operate with the file. Now, with this file object, we can read the contents of the file and print them to the screen.


```python
file = open("spider.txt")
print(file.readline())
```  
Each time we call the readline method, the file object updates the current position in the file

```python
print(file.read())
```
We can also call the read method, which reads from the current position until the end of the file instead of just one line.

```python
file.close()
```
open-use-close pattern. 

```python
with open("spider.txt") as file:
    print(file.readline())
```
Python will automatically close the file when using the "with" block.

Both the open-use-close approach and the "with" approach have their advantages. Using a "with" block is a good way to open and work on a single file then have the file automatically closed at the end of the block. On the flip side, using open outside of a block means we can use a file object in other places in our code. So we're not restricted to just one single block. But when taking this approach, we need to remember to close it when we're finished.

## Iterating through Files

```python
with open("spider.txt") as file:
    for line in file:
        print(line.upper())
```
What's happening is that the file has a new line character at the end of each line. So when Python reads the file line by line, the line variable will always have a new line character at the end. In other words, the newline character is not removed when calling read line. When we ask Python to print the line, the print function adds another new line character, creating an empty line.

```python
with open("spider.txt") as file:
    for line in file:
        print(line.strip().upper())
```

```python
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)
```
There are two things to check out on this code. First, the lines have been sorted alphabetically, so they're no longer in the order that they were in the file. Second, we can see that Python displays a newline character using "\n" symbol when printing a list of strings. This is a way of explicitly showing that there's a new line character in those strings. In general, to display a character that's not printable, Python uses escape sequences with backslash, like \n. Another common escape sequence is \t, for tab. We can also use it for escaping quotes, if we have a string that contains either a single or double quote. A quick word of caution, methods like read or readlines that read the whole file at once are useful, but we should be careful when reading the entire contents of a file into a variable of our programs. If the file is super large, it can take a lot of our computer's memory to hold it, which can lead to poor performance. If a file is just a few kilobytes like in our example here, it's fine to read it and process it completely in memory. But for large files, like the big log file of hundreds and hundreds of megabytes of data, it's more efficient to process it line by line.

## Writing Files

```python
with open("novel.txt", "w") as file:
    file.write("It was a dark and stormy night")
```


# Managing Files and Directories

## Working with Files
```python
# prints current workding directory
print(os.getcwd())
```

```python
os.mkdir("new_dir")
```

```python
os.chdir("new_dir")
```

```python
os.getcwd()
```

```python
os.mkdir("newer_dir")
os.rmdir("newer_dir")
```

```python
os.listdir("website")
dir = "website"
for name in os.listdir(dir):
    fullname = os.path.join(dir, name)
    if os.path.isdir(fullname):
        print("{} is a directory".format(fullname))
    else:
        print("{} is a file".format(fullname))
```

