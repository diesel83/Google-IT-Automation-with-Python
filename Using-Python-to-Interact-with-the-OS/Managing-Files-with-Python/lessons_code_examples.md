Dumping code examples for each submodule here. This makes it easier for me to review quickly and hopefully keeps me awake. 

# Using Python to Interact with the Operating System
## Reading and Writing Files

### Reading Files

When we open a file the OS checks permissions to access the file and then gives our code a file descriptor. This is a token generated by the OS that allows programs to do more operations with the file. In Python, this file descriptor is stored as an attribute of the files object. The file object gives us a bunch of methods that we can use to operate with the file. Now, with this file object, we can read the contents of the file and print them to the screen.


```python
file = open("spider.txt")
print(file.readline())
```  
Each time we call the readline method, the file object updates the current position in the file

```python
print(file.read())
```
We can also call the read method, which reads from the current position until the end of the file instead of just one line.

```python
file.close()
```
open-use-close pattern. 

```python
with open("spider.txt") as file:
    print(file.readline())
```
Python will automatically close the file when using the "with" block.

Both the open-use-close approach and the "with" approach have their advantages. Using a "with" block is a good way to open and work on a single file then have the file automatically closed at the end of the block. On the flip side, using open outside of a block means we can use a file object in other places in our code. So we're not restricted to just one single block. But when taking this approach, we need to remember to close it when we're finished.

### Iterating through Files

```python
with open("spider.txt") as file:
    for line in file:
        print(line.upper())
```
What's happening is that the file has a new line character at the end of each line. So when Python reads the file line by line, the line variable will always have a new line character at the end. In other words, the newline character is not removed when calling read line. When we ask Python to print the line, the print function adds another new line character, creating an empty line.

```python
with open("spider.txt") as file:
    for line in file:
        print(line.strip().upper())
```

```python
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)
```
There are two things to check out on this code. First, the lines have been sorted alphabetically, so they're no longer in the order that they were in the file. Second, we can see that Python displays a newline character using "\n" symbol when printing a list of strings. This is a way of explicitly showing that there's a new line character in those strings. In general, to display a character that's not printable, Python uses escape sequences with backslash, like \n. Another common escape sequence is \t, for tab. We can also use it for escaping quotes, if we have a string that contains either a single or double quote. A quick word of caution, methods like read or readlines that read the whole file at once are useful, but we should be careful when reading the entire contents of a file into a variable of our programs. If the file is super large, it can take a lot of our computer's memory to hold it, which can lead to poor performance. If a file is just a few kilobytes like in our example here, it's fine to read it and process it completely in memory. But for large files, like the big log file of hundreds and hundreds of megabytes of data, it's more efficient to process it line by line.

### Writing Files

```python
# using "w" will open and overwrite any of the files contents
with open("novel.txt", "w") as file:
    file.write("It was a dark and stormy night")
```


## Managing Files and Directories

### Working with Files

```python
import os
os.remove("novel.txt")
```

```python
os.rename("first_draft.txt", "finished_masterpiece.txt")
```

```python
os.path.exists("finished_masterpiece.txt")
```
### More File Information

```python
# returns filesize in bytes
os.path.getsize("spider.txt")
```
```python
# returns a unix timestamp (represents the number of seconds since January 1st, 1970)
os.path.getmtime("spider.txt")
```

```python
import datetime
timestamp = os.path.getmtime("spider.txt")
datetime.datetime.fromtimestamp(timestamp)
```

```python
# absolute path
os.path.abspath("spider.txt")
```

### Directories

```python
# prints current workding directory
print(os.getcwd())
```

```python
# creates dir
os.mkdir("new_dir")
```

```python
# changes into dir
os.chdir("new_dir")
```

```python
os.getcwd()
```

```python
os.mkdir("newer_dir")
# remove dir (only works if dir is empty)
os.rmdir("newer_dir")
```

```python
os.listdir("website")
dir = "website"
for name in os.listdir(dir):
    fullname = os.path.join(dir, name)
    if os.path.isdir(fullname):
        print("{} is a directory".format(fullname))
    else:
        print("{} is a file".format(fullname))
```

Maybe you're wondering what's up with that join function? It seems to just add a slash between two strings. Well, the join function let's us be independent from the operating system again. In Linux and MacOS, the portions of a file are split using a forward slash. On Windows, they're split using a backslash. By using the os.path.join function instead of explicitly adding a slash, we can make sure that our scripts work with all operating systems. It's another one of those handy little tools that help us avoid errors when working on different platforms.

## Reading and Writing CSV Files

### Reading CSV Files

```python
import csv
f = open("csv_file.txt")
csv_f = csv.reader(f)
for row in csv_f:
    name, phone, role = row
    print("Name: {}, Phone: {}, Role: {}".format(name, phone, role))
    f.close()
```

### Generating CSV

```python
hosts = [["workstation.local", "192.168.25.46",], ["webserver.cloud", "10.2.5.6"]]
with open('hosts.csv', 'w') as hosts_csv
    writer = csv.writer(hosts_csv)
    writer.writerows(hosts)
```

### Reading and Writing CSV Files with Dictionaries

```python
with open('software.csv') as software:
    reader = csv.DictReader(software)
    for row in reader:
        print(("{} has {} users").format(row["name"], row["users"]))
```

```python
users = [ {"name": "Sol Mansi", "username": "solm", "department": "IT infrastructure"}, 
    {"name": "Lio Nelson", "username": "lion", "department": "User Experience Research"},
    {"name": "Charlie Grey", "username": "greyc", "department": "Development"}]
# define list of keys we wnat to write to the file
keys = ["name", "username", "department"]
with open('by_department.csv', 'w') as by_department:
    # create DictWriter passing the keys
    writer = csv.DictWriter(by_department, fieldnames=keys)
    # writeheader() will create the first line of the CSV based on keys
    writer.writeheader()
    # writerows() will turn the list of dictionaries into lines in that file
    writer.writerows(users)
```